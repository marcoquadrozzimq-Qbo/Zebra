<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Generatore Etichette Zebra (203dpi)</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; font-size: 16px; }
  label { display: block; margin-top: 10px; }
  input, select, button { font-size: 16px; margin-top: 4px; }
  canvas { border: 1px solid #ccc; margin-top: 10px; background: white; display: block; }
  textarea { width: 100%; margin-top: 10px; font-size: 14px; }
  .section { border: 1px solid #ccc; padding: 10px; border-radius: 8px; margin-top: 10px; }
</style>
</head>
<body>

<h2>Generatore ZPL per Zebra ZT420 (203 dpi)</h2>

<label>Carica immagine:
  <input type="file" id="imageInput" accept="image/*">
</label>

<label>Larghezza etichetta (cm):
  <input type="number" id="labelWidth" value="14.79" step="0.01">
</label>

<label>Altezza etichetta (cm):
  <input type="number" id="labelHeight" value="20.9" step="0.01">
</label>

<label>Larghezza immagine (cm):
  <input type="number" id="imgWidth" value="3.0" step="0.1">
</label>

<label>Altezza immagine (cm):
  <input type="number" id="imgHeight" value="4.0" step="0.1">
</label>

<label>Offset immagine X (mm):
  <input type="number" id="offsetImgX" value="0" step="0.1">
</label>

<label>Offset immagine Y (mm):
  <input type="number" id="offsetImgY" value="0" step="0.1">
</label>

<label>Orientamento immagine:
  <select id="orientation">
    <option value="0">Orizzontale</option>
    <option value="90">Verticale</option>
  </select>
</label>

<label>Numero immagini:
  <input type="number" id="numImages" value="1" min="1">
</label>

<label>
  <input type="checkbox" id="enableTexts"> Abilita testi
</label>

<div id="textOptions" class="section" style="display:none;">
<h4>Opzioni Testo</h4>

<label>Testo sopra immagine:
  <input type="text" id="textTop" placeholder="Testo sopra">
</label>
<label>Offset Y sopra (mm):
  <input type="number" id="offsetTop" value="5" step="0.1">
</label>
<label>Raggio curvatura sopra (mm):
  <input type="number" id="radiusTop" value="30" step="1">
</label>
<label>
  <input type="checkbox" id="curveTop"> Testo curvato sopra
</label>

<label>Testo sotto immagine:
  <input type="text" id="textBottom" placeholder="Testo sotto">
</label>
<label>Offset Y sotto (mm):
  <input type="number" id="offsetBottom" value="5" step="0.1">
</label>
<label>Raggio curvatura sotto (mm):
  <input type="number" id="radiusBottom" value="30" step="1">
</label>
<label>
  <input type="checkbox" id="curveBottom"> Testo curvato sotto
</label>

<label>Testo a sinistra (verticale dal basso verso l'alto):
  <input type="text" id="textLeft" placeholder="Testo sinistro">
</label>
<label>Offset X sinistra (mm):
  <input type="number" id="offsetLeft" value="5" step="0.1">
</label>

<label>Testo a destra (verticale dall'alto verso il basso):
  <input type="text" id="textRight" placeholder="Testo destro">
</label>
<label>Offset X destra (mm):
  <input type="number" id="offsetRight" value="5" step="0.1">
</label>

</div>

<button id="generate">Genera ZPL</button>
<button id="download" style="display:none;">Scarica file .zpl</button>

<h3>Anteprima etichetta:</h3>
<canvas id="preview"></canvas>

<script>
// Conversione cm -> pixel per 203 dpi (8 px/mm)
const cmToPx = cm => Math.round(cm * 203 / 2.54);
const mmToPx = mm => Math.round(mm * 203 / 25.4);

const enableTexts = document.getElementById('enableTexts');
const textOptions = document.getElementById('textOptions');
enableTexts.addEventListener('change', () => {
  textOptions.style.display = enableTexts.checked ? 'block' : 'none';
});

document.getElementById('generate').addEventListener('click', async () => {
  const imgInput = document.getElementById('imageInput').files[0];
  if (!imgInput) return alert('Carica prima un\'immagine.');

  const labelWidthPx = cmToPx(+document.getElementById('labelWidth').value);
  const labelHeightPx = cmToPx(+document.getElementById('labelHeight').value);
  let imgWidthPx = cmToPx(+document.getElementById('imgWidth').value);
  let imgHeightPx = cmToPx(+document.getElementById('imgHeight').value);

  const offsetX = mmToPx(+document.getElementById('offsetImgX').value);
  const offsetY = mmToPx(+document.getElementById('offsetImgY').value);

  const numImages = +document.getElementById('numImages').value;
  const orientation = +document.getElementById('orientation').value;

  const img = new Image();
  img.src = URL.createObjectURL(imgInput);
  await img.decode();

  if (orientation === 90) { // ruota immagine
    [imgWidthPx, imgHeightPx] = [imgHeightPx, imgWidthPx];
  }

  const canvas = document.getElementById('preview');
  canvas.width = labelWidthPx;
  canvas.height = labelHeightPx;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const perRow = Math.floor((labelWidthPx - offsetX) / imgWidthPx);
  const rows = Math.ceil(numImages / perRow);
  const totalHeight = rows * imgHeightPx;

  if (imgWidthPx + offsetX > labelWidthPx || totalHeight + offsetY > labelHeightPx) {
    alert("⚠️ Le immagini non rientrano nei bordi dell'etichetta.");
    return;
  }

  for (let i = 0; i < numImages; i++) {
    const col = i % perRow;
    const row = Math.floor(i / perRow);
    const x = offsetX + col * imgWidthPx;
    const y = offsetY + row * imgHeightPx;

    ctx.save();
    if (orientation === 90) {
      ctx.translate(x + imgWidthPx / 2, y + imgHeightPx / 2);
      ctx.rotate(90 * Math.PI / 180);
      ctx.drawImage(img, -imgHeightPx/2, -imgWidthPx/2, imgHeightPx, imgWidthPx);
    } else {
      ctx.drawImage(img, x, y, imgWidthPx, imgHeightPx);
    }
    ctx.restore();

    if (enableTexts.checked) {
      ctx.fillStyle = "black";
      ctx.font = `${cmToPx(0.4)}px Arial`;
      ctx.textAlign = "center";

      const centerX = x + imgWidthPx/2;
      const centerY = y + imgHeightPx/2;

      // Preleva valori testi
      const textTop = document.getElementById('textTop').value;
      const textBottom = document.getElementById('textBottom').value;
      const textLeft = document.getElementById('textLeft').value;
      const textRight = document.getElementById('textRight').value;

      const offsetTop = mmToPx(+document.getElementById('offsetTop').value);
      const offsetBottom = mmToPx(+document.getElementById('offsetBottom').value);
      const offsetLeft = mmToPx(+document.getElementById('offsetLeft').value);
      const offsetRight = mmToPx(+document.getElementById('offsetRight').value);

      const radiusTop = mmToPx(+document.getElementById('radiusTop').value);
      const radiusBottom = mmToPx(+document.getElementById('radiusBottom').value);

      const curveTop = document.getElementById('curveTop').checked;
      const curveBottom = document.getElementById('curveBottom').checked;

      // Testo sopra
      if (textTop) {
        if (curveTop) {
          const angleStep = Math.PI / (textTop.length + 1);
          const angleStart = Math.PI;
          for (let j = 0; j < textTop.length; j++) {
            const angle = angleStart + angleStep * (j + 1);
            const tx = centerX + radiusTop * Math.cos(angle);
            const ty = y - offsetTop + radiusTop * Math.sin(angle);
            ctx.save();
            ctx.translate(tx, ty);
            ctx.rotate(angle + Math.PI/2);
            ctx.fillText(textTop[j], 0,0);
            ctx.restore();
          }
        } else {
          ctx.fillText(textTop, centerX, y - offsetTop);
        }
      }

      // Testo sotto
      if (textBottom) {
        if (curveBottom) {
          const angleStep = Math.PI / (textBottom.length +1);
          const angleStart = 0;
          for (let j = 0; j < textBottom.length; j++) {
            const angle = angleStart + angleStep * (j + 1);
            const tx = centerX + radiusBottom * Math.cos(angle);
            const ty = y + imgHeightPx + offsetBottom + radiusBottom * Math.sin(angle);
            ctx.save();
            ctx.translate(tx, ty);
            ctx.rotate(angle - Math.PI/2);
            ctx.fillText(textBottom[j],0,0);
            ctx.restore();
          }
        } else {
          ctx.fillText(textBottom, centerX, y + imgHeightPx + offsetBottom);
        }
      }

      // Testo sinistro verticale (dal basso verso l'alto)
      if (textLeft) {
        ctx.save();
        ctx.translate(x - offsetLeft, y + imgHeightPx);
        ctx.rotate(-Math.PI/2);
        ctx.textAlign = "center";
        ctx.fillText(textLeft, imgHeightPx/2,0);
        ctx.restore();
      }

      // Testo destro verticale (dall'alto verso il basso)
      if (textRight) {
        ctx.save();
        ctx.translate(x + imgWidthPx + offsetRight, y);
        ctx.rotate(Math.PI/2);
        ctx.textAlign = "center";
        ctx.fillText(textRight, imgHeightPx/2,0);
        ctx.restore();
      }
    }
  }

  // Conversione ZPL
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  let zplData = "";
  const widthBytes = Math.ceil(canvas.width / 8);
  const totalBytes = widthBytes * canvas.height;
  for (let y = 0; y < canvas.height; y++) {
    let line = "";
    for (let x = 0; x < canvas.width; x++) {
      const i = (y*canvas.width + x)*4;
      const avg = (imageData[i]+imageData[i+1]+imageData[i+2])/3;
      line += avg>127?"0":"1";
    }
    let hex = "";
    for (let i=0;i<line.length;i+=8){
      hex += parseInt(line.substr(i,8),2).toString(16).padStart(2,'0');
    }
    zplData += hex.toUpperCase() + "\n";
  }

  const zplCode = `~DGIMAGE.GRF,${totalBytes},${widthBytes},\n${zplData}\n^XA\n^FO0,0\n^XGIMAGE.GRF,1,1^FS\n^XZ`;

  const blob = new Blob([zplCode], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const downloadBtn = document.getElementById('download');
  downloadBtn.style.display = "inline-block";
  downloadBtn.onclick = ()=>{ const a=document.createElement('a'); a.href=url;a.download="etichetta.zpl";a.click();};
});
</script>

</body>
</html>
